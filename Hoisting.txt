1.  How to run the file ? : node Hoisting.js

2.  What is the meaning of hoisting?
    Hoisting is a JavaScript behavior where we can access variables and functions even before initilization.

    Hoisting is JavaScript’s behavior of allocating memory for variable and function declarations before code execution begins.
    During the memory creation phase of the execution context:
    Function declarations are fully hoisted, meaning their entire definition is stored in memory.
    Variables declared with var are hoisted and initialized with undefined.
    Variables declared with let and const are hoisted but are not initialized, which places them in the Temporal Dead Zone (TDZ) until their declaration is evaluated.

    In most of the programming langaue the below programm will be an error because we cannot access variables and functions
    before initialization.

3.  Programm with example of hoisting :

            getName();
            console.log(x);
            var x = 7;

            function getName() {
            return console.log("JavaScript Series");
            }

            /_ OUTPUT
            JavaScript Series
            undefined
            _/

4.  Why is the output like this ?

    1.  Because as explained in the Execution-Context.txt, – During the Memory Creation Phase (also called the Hoisting phase), the JavaScript engine scans the program and allocates memory.

    2.  Function declarations are fully hoisted, so the entire getName function is stored in memory.

    3.  Variables declared with var are hoisted as well, but only their declarations are hoisted—not their assignments. Therefore, x is initialized with the value undefined.

    4.  During the Execution Phase:

        1.  getName() is executed first, so "JavaScript Series" is printed to the console.
            console.log(x) is executed next. At this moment, x exists in memory but still holds the value undefined because the assignment has not yet occurred.

        2.  The statement var x = 7; is executed afterward, assigning 7 to x, but this happens after the console.log(x) call, so it does not affect the output.
            This explains why the output is:
            JavaScript Series
            undefined

        3.  More details : Why is the output like this?
            JavaScript code is executed in two phases inside an Execution Context:

            1️⃣ Memory Creation Phase (Hoisting Phase)
            Before any line of code is executed, the JavaScript engine scans the entire program and allocates memory.
            What happens in this phase?
            Function declarations
            The full function definition is stored in memory.

            function getName() {
            console.log("JavaScript Series");
            }

            Variables declared with var
            Only the variable name is stored, and it is initialized with undefined.
            var x; // x = undefined

            At the end of this phase, memory looks conceptually like this:
            getName → function() { console.log("JavaScript Series"); }
            x → undefined
            ⚠️ No code is executed yet. Only memory allocation happens.

            2️⃣ Execution Phase
            Now the JavaScript engine executes the code line by line, from top to bottom.
            Step-by-step execution:

            1.  getName();
                The function getName is already available in memory.
                It gets executed immediately.

                Output:
                JavaScript Series

            2.  console.log(x);
                The engine looks up x in memory.

                x exists, but its value is still undefined because the assignment has not been executed yet.

                Output:
                undefined

            3.  var x = 7;
                This line executes after console.log(x).

                The value 7 is assigned to x.

                There is no console.log after this, so nothing is printed.

                ❗ Important Clarifications
                x is not 7 at the time it is logged.

                var x = 7; is split internally into:

                           var x; // hoisted → undefined
                           x = 7; // executed later

                The program does not terminate early—it runs completely.
                The assignment happens, but after the output is already produced.

5.  Programme where x is not defined
    getName();
    console.log(x);

        function getName() {
        return console.log("JavaScript Series");
        }

    1. OUTPUT
       JavaScript Series
       ReferenceError: x is not defined

6.  So undefined ≠ not defined

7.  undefined
    The variable exists but has not been assigned a value

8.  not defined
    The variable does not exist in memory

9.  What is the and getName() is a arrow function instead of normal function.

        1. Program :
                    getName();
                    console.log(getName);
                    console.log(x);

                    var x = 7;

                    var getName = () => {
                    return console.log("JavaScript Series");

                     };

        2. The arrow function is treated as the variable i.e now the getName is treated as variable.

        3. OUTPUT OF ABOVE :
                TypeError: getName is not a function

        4. Why ? since arrow functions are treated as variables, it allocates getName:undefined in the meemory creation phase.
