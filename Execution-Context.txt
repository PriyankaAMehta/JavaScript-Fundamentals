1.  JavaScript Execution Context

    1. Everything in JavaScript happens inside the execution context.
    2. Every browser has its own JavaScript Engine.
    3. Execution context in the JavaScript engine is a place where whole JS code is executed.
    4. Execution context is like a container.
    5. This execution context has : Memory component and Code component.

2.  Memory Component

    1. Memeory Component is the place where variables and functions are stored in key value pair.
    2. for example a:10 , fn:{}
    3. Memeory component is also called as variable enviornment

3.  Code Component

    1. Code component is the place where the code is executed.
    2. Code component is also called as Thread of Execution.
    3. Here the code is executed 1 line at a time.

4.  JavaScript is Synchrounous Single Threaded Language.
    1️⃣ Single-threaded
    Single-threaded means JavaScript can execute only one task at a time on its main thread.
    JavaScript has a single call stack, so it processes one operation before moving to another.
    JavaScript executes 1 command at a time.

    2️⃣ Synchronous
    Synchronous means JavaScript executes code line by line, in specific order.
    Each statement or command must finish executing before the next statement starts.

    Combined meaning (important)
    Because JavaScript is single-threaded and synchronous, it executes one operation at a time and moves to the next operation only after the current one completes.

5.  Whenever we run or executes a JS code, execution context is created.

6.  Example of working of execution context:

                 var n = 2;
                 function square (num){
                 var ans = num * num;
                 return ans;
                 }
                 var square2 = square(n);
                 var square4 = square(4);

                 OUTPUT :
                    4
                    16

        1. when the above code is executed or run, the global execution context is created behind the scenes.
        2. The execution context has memory component and code component
        3. The execution context is created into 2 phases : 1. Memory Creation Phase and 2. Code Execution phase

        4. MEMORY CREATION PHASE

           1. In this phase JS allocates the memory to all variables and functions.
           2. As soon as JS starts to run , It skims through the whole programme and starts to allocate the memory to variables and functions
           3. variables and functions are stored in the key:value pair.
           4. so when JS Skims through the above code, and as soon as the JS reads the
                1. First Line : var n = 2; It allocates memory for variable n
                        as n : undefined
                        SO IN THE FIRST PHASE IT STORES SPECIAL VALUE CALLED UNDEFINED FOR ALL THE VARIABLES
                2. When the JS encounters the second line and sees its a function :

                function square (num){
                 var ans = num * num;
                 return ans;
                 }

                 it stores the whole function as square:(num){var ans = num * num;return ans;}
            5. Now the pointer is at line 6 i.e var square2 = square(n);
                1. so its a variable it stores as square : undefined
            6. Now the pointer is at line 7 i.e var square4 = square(4);
                1. so its a variable and it stores it as square4 : undefined
            7. So in the first phase i.e memory creation phase, JS Engine skims through the whole program and allocates memory to variables and functions.

        5. CODE EXECUTION PHASE

            1. The JS engine once again runs through the whole program from the line 1 and starts executing the code line by line.
            2. The line 1 : var n = 2.
                    In the memory creation phase n was asssigned undefined. n:undefined
                    Now in the code execution phase the value 2 is placed in the place of undefined. so now the value 2 is assigned.now it becomes n : 2.
            3. At line 2, it sees a function and there is nothing to execute here, so the pointer moves to line 6.
            4. At line 6 i.e var square2 = square(n), here is a function invokation.
                    1. Whenever there is function invocation, a new execution context is created.
                    2. Functions are like small programmes.
                    3. This new execution context will have 2 phases 1. memeory allocation and 2. code execution phase.
                    now we are executing var square2 = square(n) which is invoking the function (num){var ans = num * num;return ans;}. so now the mini program is (num){var ans = num * num;return ans;}
                    4. In the memeory creation phase :
                        1. In the memory creation phase, the memeory is allocated to all variables and functions. variables also include the parameters i.e (num).
                        2. num : undefined
                           ans : undefined
                    5. In the code execution phase, the code is executed line by line.
                        1. The value of n in the function invokation , var square2 = square(n); where n : 2 which we have already assigned in the main code execution is passed to num.
                        2. so now num : 2
                        3. when line 2 from the mini program is encountered, var ans = num * num;
                            now it will calulate num * num i.e 2 * 2 = 4 and put it in the place of ans.
                            now ans: undefined is replaced with 4.
                            now when the pointer comes to next line i.e return ans; return tells that the program is now terminated. and return to the main control where function was invoked.
                        4. now the value of ans which is 4 is passed to square2 : undefined to square2:4
                        5. and since the program is completed , the execution context for this will be deleted.
                    6. Now the poniter moves to line square4 = square(4). This is again a function invokation and a new exxecution context is created with memory allocation phase and code executin phase.
                            1. num : undefined and ans : undefined is alloacated im the memeory execution phase.
                            2. In the code execution phase 4, is passed to  n and ans = num * num now becomes ans: 16.
                            3. the programm is executed and the execution context is deleted and now the square4: undeinede is replaced with square:16.
                    7. now the line number 7 is also executed, now the whole global execution contex is deleted.
            6.  Call Stack
                    The Call Stack is a special data structure used by JavaScript to manage execution contexts.
                    It works on the rule LIFO (Last In, First Out).
                    How the Call Stack Works
                    When a JavaScript program starts, the Global Execution Context is created.
                    This Global Execution Context is placed at the bottom of the Call Stack.
                    Whenever a function is invoked, JavaScript creates a new execution context for that function.
                    This new function execution context is pushed on top of the Call Stack.
                    When the function finishes executing and returns a value, its execution context is removed (popped) from the Call Stack.
                    Control then goes back to the execution context that is below it in the stack.
                    After the entire program finishes, the Global Execution Context is also removed, and the Call Stack becomes empty.

    An Execution Context is an internal environment where JavaScript:
    Keeps track of variables
    Handles function execution
    Manages the call stack
