1.  Example 1 :

        var x = 1;

        a(); // we can invoke or access the function even before initilization because of hoisting
        b();
        console.log(x);

        function a() {
        var x = 10;
        console.log(x);
        }

        function b() {
        var x = 100;
        console.log(x);
        }

        1. OUTPUT :
            10
            100
            1

2.  What is happening ?

            we can invoke or access the function even before initilization because of hoisting and hence the output is 10 100 1.

3.  Step 1 :

            1. When JS engine runs the above code, a global execution context is created.
            2. The execution context has 2 phases 1. Memory creation phase 2. Code execution phase.
            3. IN the memory creation phase , all the variables and functions are allocated memory.

    4. Memory Creation Phase
       x : undefined
       a: (){var x = 10; console.log(x);}
       b: (){var x = 100; console.log(x);}

4.  Code execution Phase

    1.  So at line 1 var = 1, now the above x which is undefined, has value 1.
        so now x : 1 is stored in the memory.

    2.  At line 2 : it sees that there is function invocation so a new execution context is created, again
        memory creation phase and code execution phase.

        1.  Now the code where the memeory creation and code execytion phase happens is :

                                a() {
                                    var x = 10;
                                    console.log(x);
                                    }

        2.  Memory Creation phase :

                                x : undefined

        3.  Code Execution Phase :

                                line 1 : now it assigns value as 10 to variable x.
                                so now x is : x: 10

                                Line 2 : console.log(x);
                                now since the memeory has 10 stored in x from above, it will log the value as 10 on console and hence 10 is printed on console.

        4.  Now since the program is executed , the above execution context is deleted and the control goes back to global execution context, now at line 3.

    3.  Now the pointer is at line 3: b();

                            it sees that there is function invocation so again a new execution context is created, again
                            with memory creation phase and code execution phase.

        1.  Now the code where the memeory creation and code execytion phase happens is :

                                b() {
                                    var x = 100;
                                    console.log(x);
                                    }

        2.  Memory Creation phase :

                                x : undefined

        3.  Code Execution Phase :

                                line 1 : now it assigns value as 100 to variable x.
                                so now x is : x: 100

                                Line 2 : console.log(x);
                                now since the memeory has 100 stored in x from above, it will log the value as 100 on console and hence 10 is printed on console.

        4.  Now since the program is executed , the above execution context is deleted and the control goes back to global execution context, now at line 4.

    4.  Line 4 : console.log(x)

        1. The JS now looks for x in the local space i.e in the first line of code execution phase, x was assigned value as in the memory. so 1 is printed on the console when the line console.log(x); is executed.

    5.  Now there is not to execute so program terminates and the global execution context is also deleted.
